/*								*/
/* testdeclerr.c - written by Martin Gonda, 29-11-95 to 4-12-95 */
/* 								*/
/* code to test the handling of declarations - ie. get as many  */
/* errors as possible generated by the decl.c module            */
/*								*/ 

char str[20]                    /* error: expected ;           */
char str1;
typdef int myint;               /* error: undeclared ident 'typdef' */
myint amy;                      /* error: undeclared ident myint */
amy = 5;                        /* error: undeclared ident amy   */

int a;
float a;                        /* error: Ambiguous redeclaration */

int .*b;                        /* error: declaration error           */
int *0b;                        /* error: direct declarator error     */
int b;
static register int *b;         /* error: multiple storage class used */
register int *b;                /* error: illegal storage class usage */
short double int b;             /* error: declaration type specifn err*/
int c = ;                       /* error: illegal cast operation      */
int d[10] = 10;                 /* error: missing { in initialisation */
char e[4] = "abcde";            /* warn:  char array too long         */
char f[5] = e;                  /* error: missing { in initialisation */
int g[2] = "abcde";             /* error: illegal initialisation      */
int h[2][2] = { 1,2,3,4,5 };    /* error: too many initialisers       */
int i[3] = { 1,2,,};            /* error: illegal initialisation      */
                                /*        (missing initialiser)       */
int j, struct;                  /* error: init decl list error        */
int k({});                      /* error: syntax error                */
{ int l[] = {1,2,3}; }          /* error: initialisation not supportd */
				/*  for non scalar local types        */
int ;                           
int m = f;                      /* SHOULD give error/warning ??.....  */
int (n);
int o["n"];                     /* error: const int express'n needed  */
int (int o);                    /* error: declarator error            */
int (;                          /* error: declarator err              */

enum .p;                        /* error: enumeration declaration err */
enum q;                         /* OK ? */
enum { abc };                   /* OK ? */
enum { en = };			/* error: assignment must be constant */
enum {};     			/* error: expected ident int enum     */
     
/* void printf(void); */	/* warn: 2nd prototype of built-in fn */
int r[j];                       /* error: const int expression needed */
struct s {int a,b; } ab = 1,2;  /* error: missing { in initialisation */
struct {int a,a,b[];};          /* error: duplication of identifier.. */
                                /* error: incomplete data type for b  */
struct {};                      /* error: struct/union list decl error*/
struct t {int x, int y;} point; /* error: struct/union member decl err*/
struct { struct;};              /* error: struct/union member decl err*/
struct { int first: 1;          /* error: bit fields not supported    */
	 int second: 2; };      /* error: bit fields not supported    */
                                /* error: struct/union member decl err*/
void funcA(char .*s) {1;}       /* error: param declaration error     */
void funcA(char *s) {1;}	/* error: decl type spec error        */
void funcB(char *s, ..){1;}     /* error: expected ...                */
void funcB(int i);		/* SHOULD give warning or error !!    */
void funcB(char c);     
     
int  funcC(int a,struct {int v, int y;} d , float x)
                                /* error: struct union member decl err*/
{
    struct node;
    struct head { struct node *next;};
    struct node { struct head *hd;};
    return d.v + d.y * x + a;   /* error: illegal struct operation    */
}


int oldstyle(a,b,c)             /* error: old style C function def'n  */
  int a,b,c;
{
      return a+b+c;             /* PLUS additional errors since fn not */
				/* parsed properly */
}

int funcD(static int a,struct {int v, y;} d , float x)
                                /* error:  static param not allowed   */ 
{               
    return d.v + d.y * x + a;				   
}
    
void funcD(void)                /* error: ambiguous re-decl'n of func */
{
    void badfunc(void) { c; }   /* error: illegal fn defn             */
    void badfunc(int c) { }     /* warn:  empty function              */
				/* should give error - ill func def'n */
/*    printf("hello stupid\n");*/
}
;;
void funcE()();                 /* error: illegal return type */

float f1, f2;
int i1,i2,f2;			/* error: ambiguous redeclaration  */
int i1,i2,f2;			/* error: re-decl of identifier i1 */


void T()
{
    register int i;
    int *p, k;
    p = &i;                     /* error: cannot apply & to a register */
				/* variable */
    p = &k;
}


void fooEr(int x)
{
    /* it is an in ISO parameters have the same scope as
     * identifiers declared at the top level function
     * block;
     */
    
    int x;  /* error:  Redeclaration of parameter `x'*/
    {
       float x; /* but this should NOT generate an error */

     }
    return ;
}

void Illegal_Init()
{
    /* 3 Illegal initialization: illegal address operation*/
    int x[][5] = { {1, 2, 3, 4, 0}, { 5, 6 }, { 7 } };
    int *y[] = { x[0], x[1], x[2], 0 };
}



void Illegal_Init2(void)
{
    int a1[2];
    int *p;
    
    int a2[2][2];
    int a3[2][2][2];

    a1 = p;
    a2[0] = a1;
    a3[0] = a2;
    a3[0][0] = a1;
    
}

;;

int a1[2];
int *p;

int a2[2][2];
int a3[2][2][2];

void Illegal_Init3(void)
{
    a1 = p;
    a2[0] = a1;
    a3[0] = a2;
    a3[0][0] = a1;
}


;;

float XX(float y) { return y + 2;}
float XX(); /* error: Ambiguous re-declaration of `XX' */

int Missing(int x, int ) /* Missing name for Paramater 2*/
{
    return x;
} 
int SizeFault()
{
    return sizeof( int (*f)()); /* extraneous identifier `f'*/
}

typedef	void	Sigfunc(int);	/* for signal handlers */
Sigfunc	*signal_intr(int, Sigfunc *);/* {Prog signal_intr_function} */

Sigfunc abc33(void);  /* illegal return type for abc33 */



